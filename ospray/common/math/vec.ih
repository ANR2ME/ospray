/*! \file vec.ih implements common math/vector functionality for ISPC */

#ifndef OSPRAY_VEC_ISPH
#define OSPRAY_VEC_ISPH

#include "math.ih"

#define __define_ispc_vector2(TYPE,ABB)         \
  struct vec2##ABB {                            \
    TYPE x; TYPE y;                             \
  };                                            \
  
#define __define_ispc_vector3(TYPE,ABB)         \
  struct vec3##ABB {                            \
    TYPE x,y,z;                                 \
  };                                            \
  struct vec3##ABB##a {                         \
    TYPE x,y,z,a;                               \
  };                                            \
  
#define __define_ispc_vector4(TYPE,ABB)         \
  struct vec4##ABB {                            \
    TYPE x,y,z,w;                               \
  };                                            \

__define_ispc_vector2(int,i);
__define_ispc_vector2(unsigned int,ui);
__define_ispc_vector2(float,f);

__define_ispc_vector3(int,i);
__define_ispc_vector3(unsigned int,ui);
__define_ispc_vector3(float,f);

__define_ispc_vector4(int,i);
__define_ispc_vector4(unsigned int,ui);
__define_ispc_vector4(float,f);

#undef __define_ispc_vector2
#undef __define_ispc_vector3
#undef __define_ispc_vector4




/*! defines all constructors "make_vec2[T]" for 2-vector type */
#define __define_ispc_constructors2(UV,TYPE,ABB,ITYPE,IABB) \
  inline UV vec2##ABB make_vec2##ABB(const UV ITYPE x,      \
                                     const UV ITYPE y)      \
  {                                                         \
    UV vec2##ABB ret;                                       \
    ret.x = x;                                              \
    ret.y = y;                                              \
    return ret;                                             \
  }                                                         \
  
/*! defines all constructors "make_vec3[T]" and "make_vec3[T]a" for
  3-vector type */
#define __define_ispc_constructors3(UV,TYPE,ABB,ITYPE,IABB)   \
  inline UV vec3##ABB make_vec3##ABB(const UV ITYPE x)        \
  {                                                           \
    UV vec3##ABB ret;                                         \
    ret.x = x;                                                \
    ret.y = x;                                                \
    ret.z = x;                                                \
    return ret;                                               \
  }                                                           \
  inline UV vec3##ABB##a make_vec3##ABB##a(const UV ITYPE x)  \
  {                                                           \
    UV vec3##ABB##a ret;                                      \
    ret.x = x;                                                \
    ret.y = x;                                                \
    ret.z = x;                                                \
    return ret;                                               \
  }                                                           \
  inline UV vec3##ABB make_vec3##ABB(const UV ITYPE x,        \
                                     const UV ITYPE y,        \
                                     const UV ITYPE z)        \
  {                                                           \
    UV vec3##ABB ret;                                         \
    ret.x = x;                                                \
    ret.y = y;                                                \
    ret.z = z;                                                \
    return ret;                                               \
  }                                                           \
  inline UV vec3##ABB##a make_vec3##ABB##a(const UV ITYPE x,  \
                                           const UV ITYPE y,  \
                                           const UV ITYPE z)  \
  {                                                           \
    UV vec3##ABB##a ret;                                      \
    ret.x = x;                                                \
    ret.y = y;                                                \
    ret.z = z;                                                \
    return ret;                                               \
  }                                                           \
  
/*! defines all constructors "make_vec4[T]" for 4-vector type */
#define __define_ispc_constructors4(UV,TYPE,ABB,ITYPE,IABB) \
  /*! construct vec4 from a single scalar */                \
  inline UV vec4##ABB make_vec4##ABB(const UV ITYPE f)      \
  {                                                         \
    UV vec4##ABB ret;                                       \
    ret.x = f;                                              \
    ret.y = f;                                              \
    ret.z = f;                                              \
    ret.w = f;                                              \
    return ret;                                             \
  }                                                         \
  /*! construct vec4 from a 4 scalars */                    \
  inline UV vec4##ABB make_vec4##ABB(const UV ITYPE x,      \
                                     const UV ITYPE y,      \
                                     const UV ITYPE z,      \
                                     const UV ITYPE w)      \
  {                                                         \
    UV vec4##ABB ret;                                       \
    ret.x = x;                                              \
    ret.y = y;                                              \
    ret.z = z;                                              \
    ret.w = w;                                              \
    return ret;                                             \
  }                                                         \
  /*! construct vec4 from another vec4 (of another type) */ \
  inline UV vec4##ABB make_vec4##ABB(const UV vec4##IABB v) \
  {                                                         \
    UV vec4##ABB ret;                                       \
    ret.x = v.x;                                            \
    ret.y = v.y;                                            \
    ret.z = v.z;                                            \
    ret.w = v.w;                                            \
    return ret;                                             \
  }                                                         \


#define __define_ispc_lift_constructors4(UV,TYPE,ABB)             \
  /*! lift vec4 from vec3; fill in with 0es */                    \
  inline UV vec4##ABB make_vec4##ABB(const UV vec3##ABB v)        \
  {                                                               \
    UV vec4##ABB ret;                                             \
    ret.x = (TYPE)v.x;                                            \
    ret.y = (TYPE)v.y;                                            \
    ret.z = (TYPE)v.z;                                            \
    ret.w = (TYPE)0;                                              \
    return ret;                                                   \
  }                                                               \
  
#define __define_ispc_constructors_uv_t(UV,OTYPE,OABB,ITYPE,IABB) \
  __define_ispc_constructors2(UV,OTYPE,OABB,ITYPE,IABB)           \
  __define_ispc_constructors3(UV,OTYPE,OABB,ITYPE,IABB)           \
  __define_ispc_constructors4(UV,OTYPE,OABB,ITYPE,IABB)           \
  
#define __define_ispc_constructors_uv(UV,TYPE,ABB)              \
  __define_ispc_constructors_uv_t(UV,TYPE,ABB,int,i)            \
  __define_ispc_constructors_uv_t(UV,TYPE,ABB,unsigned int,ui)  \
  __define_ispc_constructors_uv_t(UV,TYPE,ABB,float,f)          \
  __define_ispc_lift_constructors4(UV,TYPE,ABB)                  \
  
#define __define_ispc_constructors(UV)              \
  __define_ispc_constructors_uv(UV,unsigned int,ui) \
  __define_ispc_constructors_uv(UV,int,i)           \
  __define_ispc_constructors_uv(UV,float,f)         \
  
__define_ispc_constructors(uniform);
__define_ispc_constructors(varying);

#undef __define_ispc_constructors2
#undef __define_ispc_constructors3
#undef __define_ispc_constructors3a
#undef __define_ispc_constructors4
#undef __define_ispc_lift_constructors4
#undef __define_ispc_constructors_uv
#undef __define_ispc_constructors


// for now, let's implement those manually - should eventually do those via a macro!

// ------------------------------------------------------------------
// vec3f * float
// ------------------------------------------------------------------
inline uniform vec3f operator*(const uniform vec3f &v, const uniform float f)
{ return make_vec3f(v.x*f,v.y*f,v.z*f); }
inline vec3f operator*(const vec3f &v, const float f)
{ return make_vec3f(v.x*f,v.y*f,v.z*f); }
// ------------------------------------------------------------------
// float * vec3f
// ------------------------------------------------------------------
inline uniform vec3f operator*(const uniform float f, const uniform vec3f v)
{ return make_vec3f(v.x*f,v.y*f,v.z*f); }
inline vec3f operator*(const float f, const vec3f v)
{ return make_vec3f(v.x*f,v.y*f,v.z*f); }

// ------------------------------------------------------------------
// vec4f * float
// ------------------------------------------------------------------
inline uniform vec4f operator*(const uniform vec4f &v, const uniform float f)
{ return make_vec4f(v.x*f,v.y*f,v.z*f,v.w*f); }
inline vec4f operator*(const vec4f &v, const float f)
{ return make_vec4f(v.x*f,v.y*f,v.z*f,v.w*f); }
// ------------------------------------------------------------------
// float * vec4f
// ------------------------------------------------------------------
inline uniform vec4f operator*(const uniform float f, const uniform vec4f v)
{ return make_vec4f(v.x*f,v.y*f,v.z*f,v.w*f); }
inline vec4f operator*(const float f, const vec4f v)
{ return make_vec4f(v.x*f,v.y*f,v.z*f,v.w*f); }

// ------------------------------------------------------------------
// operator '-'
// ------------------------------------------------------------------
inline vec3f operator-(const vec3f a, const vec3f b)               
{ return make_vec3f(a.x-b.x,a.y-b.y,a.z-b.z); }                
inline uniform vec3f operator-(const uniform vec3f a,               
                               const uniform vec3f b)               
{ return make_vec3f(a.x-b.x,a.y-b.y,a.z-b.z); }                

// ------------------------------------------------------------------
// operator '+'
// ------------------------------------------------------------------
inline vec3f operator+(const vec3f a, const vec3f b)               
{ return make_vec3f(a.x+b.x,a.y+b.y,a.z+b.z); }                
inline uniform vec3f operator+(const uniform vec3f a,               
                               const uniform vec3f b)               
{ return make_vec3f(a.x+b.x,a.y+b.y,a.z+b.z); }                

inline vec4f operator+(const vec4f a, const vec4f b)               
{ return make_vec4f(a.x+b.x,a.y+b.y,a.z+b.z,a.w+b.w); }                
inline uniform vec4f operator+(const uniform vec4f a,               
                               const uniform vec4f b)               
{ return make_vec4f(a.x+b.x,a.y+b.y,a.z+b.z,a.w+b.w); }                
// ------------------------------------------------------------------
// operator '*'
// ------------------------------------------------------------------
inline vec3f operator*(const vec3f a, const vec3f b)               
{ return make_vec3f(a.x*b.x,a.y*b.y,a.z*b.z); }                
inline uniform vec3f operator*(const uniform vec3f a,               
                               const uniform vec3f b)               
{ return make_vec3f(a.x*b.x,a.y*b.y,a.z*b.z); }                


// ------------------------------------------------------------------
// dot product
// ------------------------------------------------------------------
/*! computes 3D dot product for *all-uniform* vec3fs */
inline uniform float dot(const uniform vec3f &a, const uniform vec3f &b)
{ return a.x*b.x+a.y*b.y+a.z*b.z; }
/*! computes 3D dot product for vec3fs that produce varying results */
inline float dot(const vec3f &a, const vec3f &b)
{ return a.x*b.x+a.y*b.y+a.z*b.z; }

// ------------------------------------------------------------------
// cross product
// ------------------------------------------------------------------
/*! computes 3D cross product for *all-uniform* vec3fs */
inline uniform vec3f cross(const uniform vec3f &a, const uniform vec3f &b)
{ return make_vec3f(a.y*b.z-a.z*b.y,
                    a.z*b.x-a.x*b.z,
                    a.x*b.y-a.y*b.x); }
/*! computes 3D cross product for vec3fs that produce varying results */
inline vec3f cross(const vec3f &a, const vec3f &b)
{ return make_vec3f(a.y*b.z-a.z*b.y,
                    a.z*b.x-a.x*b.z,
                    a.x*b.y-a.y*b.x); }


// ------------------------------------------------------------------
// normalize
// ------------------------------------------------------------------
/*! compute and return normalized version of uniform vec3f passed to this fct */
inline uniform vec3f normalize(const uniform vec3f &v) 
{ return v * (1.f/sqrt(dot(v,v))); }
/*! compute and return normalized version of varying vec3f passed to this fct */
inline vec3f normalize(const vec3f &v) 
{ return v * (1.f/sqrt(dot(v,v))); }



// ------------------------------------------------------------------
// vector functions (abs,rcp,...):
// ------------------------------------------------------------------
/*! return vector of absolute values of input vector */
inline uniform vec3f abs(const uniform vec3f v) 
{ return make_vec3f(abs(v.x),abs(v.y),abs(v.z)); }
/*! return vector of absolute values of input vector */
inline vec3f abs(const vec3f v) 
{ return make_vec3f(abs(v.x),abs(v.y),abs(v.z)); }
/*! return vector of reciprocals of input vector */
inline uniform vec3f rcp(const uniform vec3f v) 
{ return make_vec3f(rcp(v.x),rcp(v.y),rcp(v.z)); }
/*! return vector of reciprocals of input vector */
inline vec3f rcp(const vec3f v) 
{ return make_vec3f(rcp(v.x),rcp(v.y),rcp(v.z)); }

#endif

