// ======================================================================== //
// Copyright 2009-2016 Intel Corporation                                    //
//                                                                          //
// Licensed under the Apache License, Version 2.0 (the "License");          //
// you may not use this file except in compliance with the License.         //
// You may obtain a copy of the License at                                  //
//                                                                          //
//     http://www.apache.org/licenses/LICENSE-2.0                           //
//                                                                          //
// Unless required by applicable law or agreed to in writing, software      //
// distributed under the License is distributed on an "AS IS" BASIS,        //
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. //
// See the License for the specific language governing permissions and      //
// limitations under the License.                                           //
// ======================================================================== //

#pragma once

#include "BSDF.ih"

struct Dielectric
{
  BSDF super;

  float eta;
};

inline BSDF_EvalRes Dielectric_eval(const varying BSDF* uniform super,
                                    const vec3f& wo, const vec3f& wi)
{
  return make_BSDF_EvalRes_zero();
}

inline BSDF_SampleRes Dielectric_sample(const varying BSDF* uniform super,
                                        const vec3f& wo, const vec2f& s, float ss)
{
  const varying Dielectric* uniform self = (const varying Dielectric* uniform)super;
  BSDF_SampleRes res;
  res.pdf = inf;

  // We want the actual ray direction into the surface.
  vec3f d = make_vec3f(-wo.x, -wo.y, -wo.z);
  vec3f N = getN(super);
  float eta = 1.0 / self->eta;// ior(outside) / ior(inside)
  float cos1 = dot(d, N);
  float cos1_abs = cos1;
  if (cos1_abs < 0.0) {
    cos1_abs = -cos1_abs;
  }
  vec3f dt = cos1*N;
  vec3f dp = d - dt;
  bool canReflect = ((self->eta - 1.0) < -1.0e-6 || (self->eta - 1.0) > 1.0e-6);
  bool headOn = ((cos1_abs - 1.0) > -1.0e-6 && (cos1_abs - 1.0) < 1.0e-6);
  bool mustReflect=false;
  float FresnelR;
  vec3f dirR, dirT;
  if (!canReflect) {
    FresnelR = 0;
    dirT = d;
  } else {
    if (headOn) {
     FresnelR = (eta - 1.0)/(eta + 1.0);
     FresnelR = FresnelR*FresnelR;
     dirT = d;
     dirR = make_vec3f(-d.x, -d.y, -d.z);
    } else {
      dirR = dp - dt;// already normalized.
      vec3f b = dp;
      b = normalize(b);
      float sin1 = dot(dp,b);
      float sin2 = sin1/eta;
      if (sin2 > 1.0) {// total internal reflection.
        FresnelR = 1.0;
        mustReflect = true;
      } else {
        float k = 1.0 - sin2*sin2;
        if (k < 0.0) {
          k = 0.0;
        }
        if (k > 1.0) {
          k = 1.0;
        }
        float cos2 = sqrt(k);
        vec3f N2 = dt;
        N2 = normalize(N2);
        dirT = N2*cos2 + b*sin2;
        float c1 = cos1_abs;
        float c2 = cos2;

        float r1 = (eta*c1 - c2)    /(eta*c1 + c2);
        float r2 = (c1     - eta*c2)/(c1     + eta*c2);
        FresnelR = 0.5*(r1*r1 + r2*r2);
      }
    }
  }
  if (FresnelR < 0) {// Clamp in case of roundoff error.
    FresnelR = 0;
  }
  if (FresnelR > 1.0) {
    FresnelR = 1.0;
  }
  
  // Sample the reflection or the transmission
  if ((ss < FresnelR && canReflect) || mustReflect) {
    // Reflection
    res.wi = dirR;
    res.type = BSDF_SPECULAR_REFLECTION;
    res.weight = make_vec3f(1.0f);
  } else {
    // Transmission
    res.wi = dirT;
    res.type = BSDF_SPECULAR_TRANSMISSION;
    res.weight = make_vec3f(rsqrt(self->eta)); // solid angle compression
  }

  return res;
}

inline void Dielectric_Constructor(varying Dielectric* uniform self, const varying linear3f* uniform frame,
                                   float eta)
{
  BSDF_Constructor(&self->super, BSDF_SPECULAR,
                   Dielectric_eval, Dielectric_sample,
                   frame);
  self->eta = eta;
}

inline varying BSDF* uniform Dielectric_create(uniform ShadingContext* uniform ctx, const varying linear3f* uniform frame,
                                               float eta)
{
  varying Dielectric* uniform self = (varying Dielectric* uniform)ShadingContext_alloc(ctx, sizeof(Dielectric));
  Dielectric_Constructor(self, frame, eta);
  return &self->super;
}
