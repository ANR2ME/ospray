// ======================================================================== //
// Copyright 2009-2015 Intel Corporation                                    //
//                                                                          //
// Licensed under the Apache License, Version 2.0 (the "License");          //
// you may not use this file except in compliance with the License.         //
// You may obtain a copy of the License at                                  //
//                                                                          //
//     http://www.apache.org/licenses/LICENSE-2.0                           //
//                                                                          //
// Unless required by applicable law or agreed to in writing, software      //
// distributed under the License is distributed on an "AS IS" BASIS,        //
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. //
// See the License for the specific language governing permissions and      //
// limitations under the License.                                           //
// ======================================================================== //

#pragma once

#include "../samplers/Sample.ih"
#include "ospray/math/sampling.ih"
#include "ospray/math/LinearSpace.ih"

/*! Reflects a viewing vector V at a normal N. */
inline vec3f reflect(const vec3f &V, const vec3f &N) {
  float cosi = dot(V,N);
  return (2.0f*cosi) * N - V;
}

/*! Reflects a viewing vector V at a normal N. Cosine between V
 *  and N is given as input. */
inline vec3f reflect(const vec3f &V, const vec3f &N, const float cosi) {
  return (2.0f*cosi) * N - V;
}

//! \brief Refracts a viewing vector V at a normal N
/*! \detailed Refracts a viewing vector V at a normal N using the
 *  relative refraction index eta. Eta is refraction index of outside
 *  medium (where N points into) divided by refraction index of the
 *  inside medium. The vectors V and N have to point towards the same
 *  side of the surface. The cosine between V and N is given as input
 *  and the cosine of -N and transmission ray is computed as
 *  output. */
inline Sample3f refract(const vec3f V, const vec3f N, const float eta,
                        const float cosi, float &cost)
{
  const float k = 1.0f-eta*eta*(1.0f-cosi*cosi);
  if (k < 0.0f) { cost = 0.0f; return make_Sample3f(make_vec3f(0.f),0.0f); }
  cost = sqrtf(k);
  return make_Sample3f(sub(mul(eta,sub(mul(cosi,N),V)),mul(cost,N)), sqrf(eta));
}

//! \brief Computes fresnel coefficient for dielectric medium
/*! \detailed Computes fresnel coefficient for media interface with
 *  relative refraction index eta. Eta is the outside refraction index
 *  divided by the inside refraction index. Both cosines have to be
 *  positive. */
inline float fresnelDielectric(const float cosi, const float cost, const float eta)
{
  const float Rper = (eta*cosi -     cost) * rcpf(eta*cosi +     cost);
  const float Rpar = (    cosi - eta*cost) * rcpf(    cosi + eta*cost);
  return 0.5f*(Rpar*Rpar + Rper*Rper);
}

/*! Computes fresnel coefficient for media interface with relative
 *  refraction index eta. Eta is the outside refraction index
 *  divided by the inside refraction index. The cosine has to be
 *  positive. */
inline float fresnelDielectric(const float cosi, const float eta)
{
  const float k = 1.0f-eta*eta*(1.0f-cosi*cosi);
  if (k < 0.0f) return 1.0f;
  const float cost = sqrtf(k);
  return fresnelDielectric(cosi, cost, eta);
}

/*! Computes fresnel coefficient for conductor medium with complex
 *  refraction index (eta,k). The cosine has to be positive. */
inline vec3f fresnelConductor(const float cosi, const vec3f eta, const vec3f k)
{
  vec3f tmp = eta*eta + k*k;
  vec3f Rpar
    = (tmp * cosi*cosi - 2.0f*eta*cosi + make_vec3f(1.f))
    * rcp(tmp * cosi*cosi + 2.0f*eta*cosi + make_vec3f(1.f));
  vec3f Rper
    = (tmp - 2.0f*eta*cosi + make_vec3f(cosi*cosi))
    * rcp(tmp + 2.0f*eta*cosi + make_vec3f(cosi*cosi));
  return 0.5f * (Rpar + Rper);
}

// =======================================================
struct FresnelConductor {
  vec3f eta;  //!< Real part of refraction index
  vec3f k;    //!< Imaginary part of refraction index
};

inline vec3f eval(uniform const FresnelConductor &self,
                  const float cosTheta)
{
  return fresnelConductor(cosTheta,self.eta,self.k);
}

inline uniform FresnelConductor make_FresnelConductor(const uniform vec3f eta,
                                                      const uniform vec3f k)
{
  uniform FresnelConductor m; m.eta = eta; m.k = k; return m;
}

// =======================================================
struct FresnelDielectric
{
  /*! refraction index of the medium the incident ray travels in */
  float etai;

  /*! refraction index of the medium the outgoing transmission ray
   *  travels in */
  float etat;
};

inline vec3f eval(const uniform FresnelDielectric &self,
                  const float cosTheta)
{
  return make_vec3f(fresnelDielectric(cosTheta,self.etai/self.etat));
}

inline uniform FresnelDielectric make_FresnelDielectric(const uniform float etai,
                                                        const uniform float etat)
{
  uniform FresnelDielectric m;
  m.etai = etai;
  m.etat = etat;
  return m;
}

// =======================================================
struct PowerCosineDistribution
{
  float exp;
};

inline float eval(const uniform PowerCosineDistribution &self,
                  const float cosThetaH)
{
  return (self.exp+2) * (1.0f/(2.0f*(M_PI))) * pow(abs(cosThetaH), self.exp);
  // TODO: check with powerCosineSampleHemispherePDF
}

/*! Samples the power cosine distribution. */
inline void sample(const uniform PowerCosineDistribution &self,
                   const vec3f wo,
                   const DifferentialGeometry dg,
                   Sample3f &wi,
                   const vec2f s)
{
  const vec3f wh_local = powerCosineSampleHemisphere(self.exp, s);
  const float pdf = powerCosineSampleHemispherePDF(wh_local, self.exp);
  const vec3f wh = frame(dg.Ns) * wh_local;
  vec3f r = reflect(wo, wh);
  wi = make_Sample3f(r, pdf/(4.0f*abs(dot(wo, wh))));
}

inline uniform PowerCosineDistribution make_PowerCosineDistribution(const uniform float _exp)
{
  uniform PowerCosineDistribution m;
  m.exp = _exp;
  return m;
}


inline float luminance(const vec3f& c)
{
  return 0.212671f*c.x + 0.715160f*c.y + 0.072169f*c.z;
}
