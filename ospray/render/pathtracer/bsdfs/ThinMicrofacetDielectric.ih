// ======================================================================== //
// Copyright 2009-2018 Intel Corporation                                    //
//                                                                          //
// Licensed under the Apache License, Version 2.0 (the "License");          //
// you may not use this file except in compliance with the License.         //
// You may obtain a copy of the License at                                  //
//                                                                          //
//     http://www.apache.org/licenses/LICENSE-2.0                           //
//                                                                          //
// Unless required by applicable law or agreed to in writing, software      //
// distributed under the License is distributed on an "AS IS" BASIS,        //
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. //
// See the License for the specific language governing permissions and      //
// limitations under the License.                                           //
// ======================================================================== //

#pragma once

#include "MicrofacetDielectric.ih"

// Thin microfacet dielectric BSDF with the Smith microsurface model.
// It represents a transparent slab with unit thickness, and ignores refraction.
// [Walter et al., 2007, "Microfacet Models for Refraction through Rough Surfaces"]
struct ThinMicrofacetDielectric
{
  BSDF super;

  float eta;
  GGXDistribution microfacet;
  vec3f attenuation;
  float reflectionWeight;
};

inline BSDF_EvalRes ThinMicrofacetDielectric_eval(const varying BSDF* uniform super,
                                                  const vec3f& wo, const vec3f& wi, unsigned int& lcg)
{
  const varying ThinMicrofacetDielectric* uniform self = (const varying ThinMicrofacetDielectric* uniform)super;
  BSDF_EvalRes res;

  float cosThetaO = dot(wo, getN(super));
  if (cosThetaO <= 0.f)
    return make_BSDF_EvalRes_zero();
  float cosThetaI = dot(wi, getN(super));
  bool isReflection = cosThetaI > 0.f;

  // Compute the microfacet normal
  vec3f wh;

  if (isReflection)
  {
    // Reflection
    wh = wo + wi;
  }
  else
  {
    // Transmission, but ignore refraction (reflect the direction to the other side)
    wh = wo - reflect(wi, getN(super), cosThetaI);
  }

  wh = normalize(wh);
  float cosThetaH = dot(wh, getN(super));
  if (cosThetaH < 0.f)
  {
    wh = neg(wh);
    cosThetaH = -cosThetaH;
  }

  float cosThetaOH = dot(wo, wh);
  float cosThetaIH = dot(wi, wh);

  // Fresnel term
  float cosThetaTH; // positive
  float F = fresnelDielectricWeightedEx(cosThetaOH, cosThetaTH, self->eta, self->reflectionWeight);

  if (isReflection)
  {
    // Reflection
    res.pdf = F;
    res.value = make_vec3f(F);
  }
  else
  {
    // Transmission
    res.pdf = 1.f-F;
    res.value = make_vec3f(1.f-F);

    // Apply attenuation for crossing the slab once
    float length = rcp(refract(cosThetaO, self->eta)); // rcp(cosThetaO1)
    res.value = res.value * expf(self->attenuation * length);
  }

  linear3f toLocal = transposed(getFrame(super));
  vec3f wo0 = toLocal * wo;
  vec3f wi0 = toLocal * wi;
  vec3f wh0 = toLocal * wh;

  float whPdf;
  float D = evalVisible(self->microfacet, wh0, wo0, cosThetaOH, whPdf);
  float G = evalG2(self->microfacet, wo0, wi0, cosThetaOH, cosThetaIH);

  res.pdf *= whPdf * rcp(4.f*abs(cosThetaOH));
  res.value = res.value * (D * G * rcp(4.f*cosThetaO));
  return res;
}

inline BSDF_SampleRes ThinMicrofacetDielectric_sample(const varying BSDF* uniform super,
                                                      const vec3f& wo, const vec2f& s, float ss, unsigned int& lcg)
{
  const varying ThinMicrofacetDielectric* uniform self = (const varying ThinMicrofacetDielectric* uniform)super;
  BSDF_SampleRes res;

  float cosThetaO = dot(wo, getN(super));
  if (cosThetaO <= 0.f)
    return make_BSDF_SampleRes_zero();

  linear3f toGlobal = getFrame(super);
  linear3f toLocal = transposed(getFrame(super));
  vec3f wo0 = toLocal * wo;

  // Sample the microfacet normal
  float whPdf;
  vec3f wh = toGlobal * sampleVisibleUH(self->microfacet, wo0, whPdf, s);

  float cosThetaOH = dot(wo, wh);

  // Fresnel term
  float cosThetaTH; // positive
  float F = fresnelDielectricWeightedEx(cosThetaOH, cosThetaTH, self->eta, self->reflectionWeight);

  // Sample the reflection
  res.wi = reflect(wo, wh, cosThetaOH);
  float cosThetaI = dot(res.wi, getN(super));
  if (cosThetaI <= 0.f)
    return make_BSDF_SampleRes_zero();

  float cosThetaIH = dot(res.wi, wh);
  vec3f wi0 = toLocal * res.wi;

  float G = evalG2(self->microfacet, wo0, wi0, cosThetaOH, cosThetaIH);

  bool doReflection = (ss <= F);
  if (doReflection)
  {
    // Reflection
    res.type = BSDF_GLOSSY_REFLECTION;
    res.pdf = F;
    res.weight = make_vec3f(1.f);
  }
  else
  {
    // Transmission, but ignore refraction (reflect the direction to the other side)
    res.wi = neg(reflect(res.wi, getN(super), cosThetaI));
    res.type = BSDF_GLOSSY_TRANSMISSION;
    res.pdf = (1.f-F);

    // Apply attenuation for crossing the slab once
    float length = rcp(refract(cosThetaO, self->eta)); // rcp(cosThetaO1)
    res.weight = expf(self->attenuation * length);
  }

  res.pdf *= whPdf * rcp(4.f*abs(cosThetaOH));
  res.weight = res.weight * (G * rcp_safe(evalG1(self->microfacet, wo0, cosThetaOH)));
  return res;
}

// Computes the transmittance through a thin rough dielectric surface, which requires sampling a microfacet normal
inline float ThinMicrofacetDielectric_transmittance(float cosThetaO, float eta, const GGXDistribution& microfacet,
                                                    float reflectionWeight, const vec2f& s)
{
  // Make an outgoing vector
  vec3f wo = make_vec3f(cos2sin(cosThetaO), 0.f, cosThetaO);

  // Sample the microfacet normal
  float whPdf;
  vec3f wh = sampleVisibleUH(microfacet, wo, whPdf, s);

  float cosThetaOH = dot(wo, wh);

  // Fresnel term
  float cosThetaTH; // positive
  float F = fresnelDielectricWeightedEx(cosThetaOH, cosThetaTH, eta, reflectionWeight);

  // Sample the transmission, but ignore refraction (reflect the direction to the other side)
  vec3f wi = reflect(wo, wh, cosThetaOH);
  float cosThetaI = wi.z;
  if (cosThetaI <= 0.f)
    return 0.f;

  float cosThetaIH = dot(wi, wh);
  float G = evalG2(microfacet, wo, wi, cosThetaOH, cosThetaIH);

  return (1.f-F) * (G * rcp_safe(evalG1(microfacet, wo, cosThetaOH)));
}

inline void ThinMicrofacetDielectric_Constructor(varying ThinMicrofacetDielectric* uniform self,
                                                 const varying linear3f* uniform frame,
                                                 float eta, const vec2f& alpha, vec3f attenuation,
                                                 float reflectionWeight)
{
  BSDF_Constructor(&self->super, BSDF_GLOSSY,
                   ThinMicrofacetDielectric_eval, ThinMicrofacetDielectric_sample,
                   frame);

  self->eta = eta;
  self->microfacet = make_GGXDistribution(alpha);
  self->attenuation = attenuation;
  self->reflectionWeight = reflectionWeight;
}

inline varying BSDF* uniform ThinMicrofacetDielectric_create(uniform ShadingContext* uniform ctx,
                                                             const varying linear3f* uniform frame,
                                                             float eta, const vec2f& alpha, vec3f attenuation,
                                                             float reflectionWeight)
{
  varying ThinMicrofacetDielectric* uniform self =
    (varying ThinMicrofacetDielectric* uniform)ShadingContext_alloc(ctx, sizeof(ThinMicrofacetDielectric));
  ThinMicrofacetDielectric_Constructor(self, frame, eta, alpha, attenuation, reflectionWeight);
  return &self->super;
}

// Helper function for transparent shadow rays
inline vec3f ThinMicrofacetDielectric_getTransparency(float cosThetaO,
                                                      float eta, const vec2f& alpha, vec3f attenuation,
                                                      float reflectionWeight, unsigned int& lcg)
{
  GGXDistribution microfacet = make_GGXDistribution(alpha);
  float T = ThinMicrofacetDielectric_transmittance(cosThetaO, eta, microfacet, reflectionWeight, LCG_getFloat2(lcg));

  // Compute attenuation for crossing the slab once
  float length = rcp(refract(cosThetaO, eta)); // rcp(cosThetaO1)
  vec3f A = expf(attenuation * length);

  return make_vec3f(T) * A;
}
