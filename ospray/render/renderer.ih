#pragma once

#include "ospray/common/ospcommon.ih"
#include "ospray/fb/framebuffer.ih"
#include "ospray/fb/tile.ih"
#include "ospray/common/ray.ih"

struct Renderer;
struct Model;
struct Camera;

struct ScreenSample {
  // input values to 'renderSample'
  vec3i sampleID; /*!< x/y=pixelID,z=accumID/sampleID */
  Ray   ray;      /*!< the primary ray generated by the camera */
  // return values from 'renderSample'
  vec3f rgb;      
  float alpha;
  float z;
};

/*! Render a given screen sample (as specified in sampleID), and
  returns the radiance in 'retVal'. sampleID.x and .y refer to the
  pixel ID in the frame buffer, sampleID.z indicates that this should
  be the 'z'th sample in a sequence of samples for renderers that
  support multi-sampling and/or accumulation. 

  Note that it is perfectly valid for different samples to have the
  same x, y, or even z values. For example, a accumulation-based
  renderer may issue chunks of pixels with sampleID.z all 0 in the
  first frame, sampleID.z all 1 in the second, etc, while a
  super-sampling renderer make issue a chunk of N samples together for
  the same pixel coordinates in the same call.
 */
typedef void (*Renderer_RenderSampleFct)(uniform Renderer *uniform renderer,
                                      varying ScreenSample &retValue);
typedef void (*Renderer_ToneMapFct)(uniform Renderer *uniform renderer,
                                 varying vec3f &color,
                                 const varying vec2i &pixelID);
typedef void (*Renderer_RenderTileFct)(uniform Renderer *uniform renderer,
                                    uniform Tile &tile);
typedef void (*Renderer_BeginFrameFct)(uniform Renderer *uniform renderer,
                                       uniform FrameBuffer *uniform fb);
typedef void (*Renderer_EndFrameFct)(uniform Renderer *uniform renderer, 
                                     const uniform int32 newAccumID);

struct Renderer {
  Renderer_RenderSampleFct renderSample;
  Renderer_ToneMapFct      toneMap;
  Renderer_RenderTileFct   renderTile;
  Renderer_BeginFrameFct   beginFrame;
  Renderer_EndFrameFct     endFrame;

  FrameBuffer *fb; /*!< currently rendered frame buffer. may be NULL
                     or invalid before start of, or after end of, a
                     frame */
  Model       *model; 
  Camera      *camera;
  void        *cppEquivalent;
  uint32       spp; // number of samples per pixel
};

void Renderer_constructor(uniform Renderer *uniform renderer,
                          void *uniform cppE,
                          void *uniform _model,
                          void *uniform _camera);

